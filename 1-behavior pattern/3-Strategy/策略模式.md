### 策略模式
定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。策略模式使算法可以独立与使用它的用户而变化。

策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。

策略模式：

- 定义了一族算法（业务规则）；
- 封装了每个算法；
- 这族的算法可互换代替（interchangeable）
- 不会影响到使用算法的客户.

#### 设计要点
策略模式中主要有三个角色，在设计策略模式时要找到并区分这些角色
- 上下文环境(Context)：起着承上启下的封装作用，屏蔽上层应用对策略(算法)的直接访问，封装可能存在的变化。
- 策略的抽象(Strategy)：策略(算法)抽象类，定义统一的接口，规定每个子类必须实现的方法
- 具体策略：策略的具体实现，可以有多个不同的(算法或者规则)实现

#### 策略模式优缺点
优点：
- 算法(规则)可以自由切换
- 避免使用多重条件判断
- 方便拓展和增加新的算法(规则)

缺点：
- 所有策略类都需要对外暴露

----

对于业务开发来说，业务逻辑的复杂是必然的，随着业务发展，需求只会越来越复杂，为了考虑到各种各样的情况，代码中不可避免的会出现很多if-else。

一旦代码中if-else过多，就会大大的影响其可读性和可维护性。

首先可读性，不言而喻，过多的if-else代码和嵌套，会使阅读代码的人很难理解到底是什么意思。尤其是那些没有注释的代码。

其次是可维护性，因为if-else特别多，想要新加一个分支的时候，就会很难添加，极其容易影响到其他的分支。

#### 实战应用
1. 下面来介绍如何使用策略模式 消除if …else
```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

def get_result(type, money):
    """商场促销"""
    result = money
    if money > 10000:
        if type == "UserType.SILVER_VIP":
            print("白银会员 优惠50元")
            result = money - 50
        elif type == "UserType.GOLD_VIP":
            print("黄金会员 8折")
            result = money * 0.8

        elif type == "UserType.PLATINUM_VIP":
            print("白金会员 优惠50元，再打7折")
            result = money * 0.7 - 50
        else:
            print("普通会员 不打折")
            result = money

    return result
```
2.假设有这样一个场景：  
有一个Person类,有年龄(age)、体重(weight)、身高(height)三个属性。
现在要对Person类的一组对象进行排序，但是并没有确定根据什么规则来排序，有时需要根据年龄来排序，
有时需要根据身高来排序，有时需要根据身高和体重的综合情况来排序，还有可能....  
通过对这个应用场景进行分析，我们会发现，这里使用了多种排序算法，而且需要动态的在这几种算法中进行选择。
所以必然选择策略模式
