#### 工厂模式

工厂模式三姐妹：简单工厂模式（小妹妹）、工厂方法模式（妹妹）、抽象工厂模式（姐姐）。这三种模式可以理解为同一种编程思想的三个版本，从简单到高级不断升级。

#### 简单工厂模式

这是最简单的一个版本，只有一个工厂类 SimpleFactory，类中有一个静态的创建方法createProduct，该方法根据参数传递过来的类型值（type）或名称（name）来创建具体的产品（子类）对象。

专门定义一个类来负责创建其他类的实例，根据参数的不同创建不同类的实例，被创建的实例通常具有共同的父类，这个模式叫简单工厂模式（Simple FactoryPattern）。

简单工厂模式又称为静态工厂方法模式。之所以叫“静态”，是因为在很多静态语言（如Java、C++）中方法通常被定义成一个静态（static）方法，这样便可通过类名来直接调用方法。

##### 设计思想

在故事剧情中，我们通过咖啡机制作咖啡，加入不同风味的咖啡豆就产生不同口味的咖啡。这一过程就如同一个工厂一样，我们加入不同的配料，就会生产出不同的产品，这就是程序设计中工厂模式的概念。

在工厂模式中，用来创建对象的类叫工厂类，被创建的对象的类称为产品类。源码示例15-1中CoffeeMaker就是工厂类，LatteCaffe和MochaCoffee就是产品类。源码示例15-1的类图如图15-1所示。

##### 定义

定义一个创建对象（实例化对象）的接口，通过参数来决定创建哪个类的实例。

##### 类图

![]( http://qnvqkoc5y.hn-bkt.clouddn.com/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png )

 SimpleFactory是工厂类，负责创建对象，如故事剧情中的 CoffeeMaker。Product是要创建的产品的抽象类，负责定义统一的接 口，如故事剧情中的Coffee。ProductA和ProductB是具体的产品类型， 如故事剧情中的LatteCaffe和MochaCoffee。 

##### 实现

```PYTHON
from abc import ABCMeta, abstractmethod
# 引入ABCMeta和abstractmethod来定义抽象类和抽象方法

class Coffee(metaclass=ABCMeta):
    """咖啡"""

    def __init__(self, name):
        self.__name = name

    def getName(self):
        return self.__name

    @abstractmethod
    def getTaste(self):
        pass


class LatteCaffe(Coffee):
    """拿铁咖啡"""

    def __init__(self, name):
        super().__init__(name)

    def getTaste(self):
        return "轻柔而香醇"

class MochaCoffee(Coffee):
    """摩卡咖啡"""

    def __init__(self, name):
        super().__init__(name)

    def getTaste(self):
        return "丝滑与醇厚"

class Coffeemaker:
    """咖啡机"""

    @staticmethod
    def makeCoffee(coffeeBean):
        "通过staticmethod装饰器修饰来定义一个静态方法"
        if(coffeeBean == "拿铁咖啡豆"):
            coffee = LatteCaffe("拿铁咖啡")
        elif(coffeeBean == "摩卡咖啡豆"):
            coffee = MochaCoffee("摩卡咖啡")
        else:
            raise ValueError("不支持的参数：%s" % coffeeBean)
        return coffee

def testCoffeeMaker():
    latte = Coffeemaker.makeCoffee("拿铁咖啡豆")
    print("%s已为您准备好了，口感：%s。请慢慢享用！" % (latte.getName(), latte.getTaste()) )
    mocha = Coffeemaker.makeCoffee("摩卡咖啡豆")
    print("%s已为您准备好了，口感：%s。请慢慢享用！" % (mocha.getName(), mocha.getTaste()))

testCoffeeMaker()
```



##### 优缺点

优点： 

1. 实现简单、结构清晰。 
2. 抽象出一个专门的类来负责某类对象的创建，分割出创建的 职责，不能直接创建具体的对象，只需传入适当的参数即可。
3. 使用者可以不关注具体对象的类名称，只需知道传入什么参 数可以创建哪些需要的对象。 

缺点： 

1. 不易拓展，一旦添加新的产品类型，就不得不修改工厂的创 建逻辑。不符合“开放封闭”原则，如果要增加或删除一个产品类型，就 要修改switch...case...（或if...else...）的判断代码。 
2. 当产品类型较多时，工厂的创建逻辑可能过于复杂， switch...case...（或if...else...）判断会变得非常多。一旦出错可能造成所 有产品创建失败，不利于系统的维护。

##### 应用场景

- 产品具有明显的继承关系，且产品的类型不太多。 
- 所有的产品具有相同的方法和类似的属性，使用者不关心具 体的类型，只希望传入合适的参数能返回合适的对象。 

**尽管简单工厂模式不符合“开放-封闭”原则 但因为它简单，所以仍然能在很多项目中看到它。** 



#### 工厂模式

工厂方法模式是简单工厂模式的一个升级版本，为解决简单工厂模式不符合“开放-封闭”原则的问题，我们对 SimpleFactory 进行了一个拆分，抽象出一个父类Factory，并增加多个子类分别负责创建不同的具体产品。

##### 定义

定义一个创建对象（实例化对象）的接口，让子类来决定创建哪个类的实例。工厂方法使一个类的实例化延迟到其子类。

##### 类图

![](http://qnvqkoc5y.hn-bkt.clouddn.com/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png )

Product是要创建的产品的抽象类，ProductA和ProductB是具体的产品类型。Factory是所有工厂的抽象类，负责定义统一的接口。ProductAFactory和ProductBFactory是具体的工厂类，分别负责产品ProductA和ProductB的创建。

##### 实现

```python
# -*- coding: utf-8 -*-
from abc import abstractmethod

def iter_subclass(cls, _seen=None):
    """Generator over all subclasses of a given class in depth first order.

    :param _seen: record already iter class type, type is set
    """
    if not isinstance(cls, type):
        raise TypeError(('iter_subclass must be called with '
                         'new style classes, not %s') % cls)

    _seen = _seen or set()
    try:
        subs = cls.__subclasses__()
    except TypeError:  # fails only when cls is type
        subs = cls.__subclasses__(cls)
    for sub in subs:
        if sub not in _seen:
            _seen.add(sub)
            yield sub
            for sub in iter_subclass(sub, _seen):
                yield sub


_cls_cache = {}
_cache_singleton_cls = {}


def get_cached_class(cls, name):
    u"""根据父类获取子类，并保证每个子类仅实例化一次"""
    global _cls_cache
    if cls not in _cls_cache:
        _cls_cache[cls] = list(iter_subclass(cls))

    for kls in _cls_cache[cls]:
        if name == getattr(kls, 'name', None):
            return kls
    return cls


class FactoryBase(object):
    name = None

    def __new__(cls, name, *args, **kwargs):


        if cls != FactoryBase:
            kls = cls
        else:
            kls = get_cached_class(cls, name)

        return super(FactoryBase, cls).__new__(kls)

    @abstractmethod
    def get_taste(self):
        pass


class LatteFactory(FactoryBase):
    # 拿铁
    name = 'latte'

    def get_taste(self):
        return "轻柔而香醇"


class MochaFactory(FactoryBase):
    # 摩卡
    name = 'mocha'

    def get_taste(self):
        return "丝滑与醇厚"


class  CappuccinoFactory(FactoryBase):
    # 卡布奇诺
    name = 'cappuccino'

    def get_taste(self):
        return "浓缩咖啡"


class Coffeemaker(object):

    def __new__(cls, *args, **kwargs):
        if not hasattr(Coffeemaker, "_instance"):
            Coffeemaker._instance = object.__new__(Coffeemaker)
        return Coffeemaker._instance

    def __init__(self, name, *args, **kwargs):
        super(Coffeemaker, self).__init__()
        self.factory = FactoryBase(name, *args, **kwargs)

    def make_coffee(self):
        return self.factory.get_taste()


if __name__ == '__main__':
    latte = Coffeemaker('cappuccino')
    print latte.make_coffee()
```

##### 优缺点

优点：

- 解决了简单工厂模式不符合“开放-封闭”原则的问题，使程序更容易拓展。
- 实现简单。

缺点：

- 对于有多种分类的产品，或具有二级分类的产品，工厂方法模式并不适用。

多种分类：如我们有一个电子白板程序，可以绘制各种图形，那么画笔的绘制功能可以理解为一个工厂，而图形可以理解为一种产品；图形可以根据形状分为直线、矩形、椭圆等，也可以根据颜色分为红色图形、绿色图形、蓝色图形等。

二级分类：如一个家电工厂，它可能同时生产冰箱、空调和洗衣机，那么冰箱、空调、洗衣机属于一级分类；而洗衣机又可分为高效型的和节能型的，高效型洗衣机和节能型洗衣机就属于二级分类。

##### 应用场景

- 客户端不知道它所需要的对象的类。
- 工厂类希望通过其子类来决定创建哪个具体类的对象。

**因为工厂方法模式简单且易拓展，因此在项目中应用得非常广泛，在很多标准库和开源项目中都能看到它的影子。**



#### 抽象工厂模式